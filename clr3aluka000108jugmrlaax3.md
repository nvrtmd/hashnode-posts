---
title: "[넓고 얕게 배우는 컴퓨터 구조] 정리"
datePublished: Wed Aug 03 2022 15:00:00 GMT+0000 (Coordinated Universal Time)
cuid: clr3aluka000108jugmrlaax3
slug: wide-shallow-cs-study
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1704619779966/ca43c574-47c6-4d79-b019-d2c2fc152847.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1704619749270/7c7a8500-c88a-4155-8ae5-0a35bd9c500b.png
tags: computer-science, study

---

# 컴퓨터 하드웨어 구성 요약

![](https://velog.velcdn.com/images/carmine/post/5a189c0f-f614-438a-aa82-d6d7d8102bd4/image.png)

- 메인 보드: 컴퓨터 구성요소 중 가장 큰 것
- RAM: 주기억장치
- CPU와 RAM이 정보 주고받는 것은 메인보드가 전담
- 주변 기기
  - 하드디스크: 보조 기억 장치
    - RPM: 1초에 모터가 몇 번 도는가
      - 빠르게 회전할수록 RAM과 하드디스크 사이의 입출력 속도가 빨라짐
    - 메인 보드와 연결되는 인터페이스: SATA
  - Sound card
    - 인터페이스: USB
  - 컴퓨터 속 모든 정보는 숫자
    - CPU에서 연산됨
    - 정보의 이동: 보조기억장치 -> RAM -> CPU에서 연산됨 -> MP3 파일이라 Sound card로 이동 -> 스피커 -> 소리로 출력
  - VGA(비디오카드)
    - 모니터와 연결됨 -> 모니터에서 시각화됨
      - 모니터: 컴퓨터 내에서 숫자 형태로 존재하는 정보를 시각화해서 보여주는 도구
    - 인터페이스: PCI
  - USB Disk
    - USB는 인터페이스 규격이며, 그런 인터페이스를 지원하는 보조기억장치

* 컴퓨터의 정체성 = CPU

# 1비트와 4GB, 용량

![](https://velog.velcdn.com/images/carmine/post/63209714-f3f9-4183-ada0-1a7f528af8f7/image.png)

- 전기 스위치
  - 상태
    - 전기가 흐르지 않는 상태: 0
    - 흐르는 상태: 1

![](https://velog.velcdn.com/images/carmine/post/05836600-d241-4a3f-9ba6-e7ff36ef0227/image.png)

- 2진수 네 자리 숫자
  - 한 자리에 올 수 있는 숫자의 범위: 0~1
- 진법 변환: 숫자의 진수를 변환하는 것
  - 2진수를 10진수로, 10진수를 2진수로

![](https://velog.velcdn.com/images/carmine/post/d97fbfd6-c363-4bf8-b85e-fa38111c4f92/image.png)

- 전기 스위치를 병렬로 연결해서 자릿수 표현 = 2진수 체계
  - 네 스위치를 조합했을 때 나올 수 있는 숫자의 개수는 총 2의 4제곱 가지
  - 네 개의 비트는 총 16가지 숫자를 표현할 수 있다

![](https://velog.velcdn.com/images/carmine/post/2b448f98-2be6-4962-9e7b-e3611ccef1f8/image.png)

- 4비트는 0부터 15까지 총 16가지의 숫자를 표현할 수 있음
- 8개의 비트 = 1바이트(새로운 용량 단위)
  - 영문자 한 글자가 저장될 수 있는 메모리 크기
  - 2의 10제곱은 1024

![](https://velog.velcdn.com/images/carmine/post/e5745cf4-836c-40b8-b870-c1709f3d02cc/image.png)

- 컴퓨터가 기억 공간 관리 시 1바이트 단위로 관리

# 진법 변환

![](https://velog.velcdn.com/images/carmine/post/f73de290-e8c8-4718-9c10-d096b8924de3/image.png)

- 컴퓨터 안 모든 정보는 0과 1
- 4비트와 4비트를 묶어서 8비트, 즉, 1바이트로 만들 수 있음
- 네 개의 스위치가 꺼지면 0000, 1001까지는 9, 1010은 10이 됨
- 10부터 1111, 즉, 15까지 2자리 수를 한 자리로 표현하기 위해 영문자로 대체하여 씀

![](https://velog.velcdn.com/images/carmine/post/ecf352d5-2142-44f0-8a2b-c9e4585ccfdd/image.png)

- 4비트는 16비트로 보면 한 자리 숫자임
- 16진수로 41(0x41)이라는 숫자가 있다면?
  - 4와 1이 각각 4비트이고, 0100과 0001로 변환할 수 있음
  - 0x41 = 01000001(총 8비트 = 1바이트)
    - 즉, 0x41는 용량으로 표현하자면 1바이트
  - 0x41을 16진수 -> 10진수 변환 시 (1 _ 1) + (16 _ 4) = 65
  - 01000001을 2진수 -> 10진수 변환 시 (1 _ 1) + (64 _ 1) = 65
- 0x73은 숫자 하나가 4비트이며 총 1바이트(=8비트)
  - 01110011로 변환됨
  - 0x73을 16진수 -> 10진수 변환 시 (1 _ 3) + (16 _ 7) = 115
  - 01110011을 2진수 -> 10진수 변환 시 (1 _ 1) + (2 _ 1) + (16 _ 1) + (32_ 1) + (64 \* 1) = 115

# CPU 작동 원리
![](https://velog.velcdn.com/images/carmine/post/8056ab23-4096-470e-996e-114f1c2e75c2/image.png)

- 논리 게이트 회로
- 논리의 곱
  - 2개의 인풋이 모두 참일 때만 참
- 논리의 합
  - 2개의 논리 중 하나만 참이어도 참
- 배타적(Exclusive)
  - 두 개의 입력이 서로 같으면 거짓이며 서로 다르면 참
- Not
  - 인풋이 참이면 거짓, 거짓이면 참

![](https://velog.velcdn.com/images/carmine/post/94b42a12-cd6a-4173-877d-41bae0f2ac9f/image.png)

- IC 칩
- 5V 전기를 흘려 보냄 -> And 연산 시 +5V가 출력됨
- 한 쪽엔 전기 가고 한 쪽엔 안가면 출력은 0

![](https://velog.velcdn.com/images/carmine/post/b0eb230c-5e4d-4f07-8a5f-4a647b80dd66/image.png)

- A가 1이고 B가 0일 때, S는 1, C는 0
- 반가산기: 1 개의 비트를 갖고 연산함 -> 자리올림 등의 개념이 없음

![](https://velog.velcdn.com/images/carmine/post/5412b0f9-209c-44f9-bafc-f814f7145e02/image.png)

![](https://velog.velcdn.com/images/carmine/post/4ab9d390-8479-470d-a04e-62ffdd7dee82/image.png)

- A = 2와 B = 5를 더하기
  - 4의 자리에서 자리 올림이 발생
  - 1비트 전가산기의 인풋은 A, B, C로 세 개
    - C는 자리 올림
    - 즉, 2와 5를 더할 때 4의 자리에서 발생하는 연산은 A는 0, B는 0, C는 1이 됨

![](https://velog.velcdn.com/images/carmine/post/0eb8d797-97ab-4f9e-8fd6-be1085a67cb2/image.png)

- 4비트 가산기

![](https://velog.velcdn.com/images/carmine/post/897d88e7-21cc-4242-b572-676908a1bcb8/image.png)

- 컴퓨터는 덧셈만 할 줄 알아도 된다! 왜?
  - 보수를 더하면 뺄셈
    - 만약 12 – 9 = 3 연산을 한다고 하면?
      - 9에 1을 더하면 10이 됨 -> 1은 10에 대한 보수
      - 12에서 9를 뺄 때는 12에 9의 보수인 1을 더해 버림 -> 13이 됨 -> 10의 자리를 버리고 3만 취하면 12 – 9의 답
  - 2진수 계산할 때는 2의 보수를 사용
    - 얼마를 더하면 2가 되는가?
      - 1의 보수에 1을 더하는 것
      - 1의 보수는 0을 1로, 1을 0으로 뒤집음 (= Not 연산)
    - 3 – 2 연산
      - 3은 0011, 2는 0010
        - 2의 1의 보수는 1101
        - 2의 2의 보수는 1101 + 1 = 1110
        - 3과 1110를 더하면 10001이며, 4비트까지만 인정하기 때문에 0001, 즉, 1이 됨

![](https://velog.velcdn.com/images/carmine/post/9f59d5c2-bcef-448c-b1ca-e803676fb225/image.png)

![](https://velog.velcdn.com/images/carmine/post/e915fae6-4ea0-4e4d-b413-1acbd7f80aff/image.png)

- 9를 3으로 나눌 때, 9에서 3을 뺌 -> 6은 3보다 크거나 같음 -> 3을 뺌 -> 3은 3보다 크거나 같음 -> 3을 뺌 -> 총 세 번 뺏으므로 몫은 3, 나머지는 0

![](https://velog.velcdn.com/images/carmine/post/4d752e98-b090-4d42-a892-b784bf021110/image.png)

- 0으로 나눌 수 없음
  - 7에서 0을 빼면 7, 7에서 0을 빼면 또 0 … 무한 반복 -> 열 발생 -> 칩 폭발

![](https://velog.velcdn.com/images/carmine/post/eeab5441-10bb-49b6-a246-c959e0a8c455/image.png)

- 5를 왼쪽으로 밀고 자리 올림 버리며 1의 자리에는 padding 0을 채워 넣으면 10이 됨

![](https://velog.velcdn.com/images/carmine/post/40b2eeeb-b2b9-482a-813b-6f1992cb43e7/image.png)

- 6를 오른쪽으로 밀면 3이 됨
- 컴퓨터라는 기계의 작동 원리는 게이트 회로를 조합하여 가산기를 만든 것 -> 결과적으로 사칙연산을 수행(계산기)

# 기억 장치에 대한 이해

- 기억장치: 정보, 자료를 담아두는 저장 공간
  - 공간마다 특성(속도, 휘발성 등)이 다름

![](https://velog.velcdn.com/images/carmine/post/ab3e5e15-e634-446b-83fd-2cf58e95efa9/image.png)

- RAM까지가 주기억장치, 그 아래는 보조기억장치
- 위로 갈수록 용량 크고 비용 비싸며 속도 빠름
  - 레지스터는 바이트, 캐시 메모리는 메가바이트, RAM은 기가바이트 단위
  - HDD, SSD 등은 TB~ 단위

![](https://velog.velcdn.com/images/carmine/post/7dc648ea-0a4c-4f6b-a324-336a1b87dee1/image.png)

- CPU에서는 연산이 일어남 -> 연산을 위해 RAM 내 자료, 정보를 CPU에 가져와야 함 -> 연산 뒤 결과를 RAM에 보냄
- RAM은 하드디스크 같은 보조기억장치의 정보를 가져와서 CPU에 가져다 주는 것
  - HDD는 영구 기억 -> 전원 꺼도 남아있음
- HDD(도서관)에서 정보(책)을 빌려와서 RAM(책꽂이)에 꽂아 둠 -> 그 정보를 사용하기 위해 캐시(책상)에 가져옴
  - 캐시: 책꽂이에서 책을 빨리 가져오기 위해 존재함
- 연산은 레지스터에서 일어남 -> 연산 하기 위해서는 RAM 이하의 정보를 무조건 CPU 쪽으로 가져와야 함

![](https://velog.velcdn.com/images/carmine/post/0966b7dd-ac12-48ff-9782-131a26176899/image.png)

![](https://velog.velcdn.com/images/carmine/post/71959232-6d9c-4cd0-b415-a5bd2fd83ec2/image.png)

- 10번에 문자 A 정보가 들어있음
- RAM은 CPU가 관리함 -> CPU가 관리하기 위해 RAM에 번호를 붙임 -> CPU는 ‘10번에 저장된 A를 CPU에 가져와라’ 명령 -> CPU에도 A를 담아둘 공간이 필요 = 그 공간이 레지스터 -> 연산 일어남
- 관리 체계

  - 레지스터: 이름
  - 주기억장치: 일련번호
  - 보조기억장치: 트랙 번호, 섹터 번호

- 하드디스크 어딘가에 정보 들어있음 -> 정보 들어가 있는 위치 정보가 있음 -> 트랙 + 섹터(몇 번 트랙, 몇 번 섹터의 A를 가져와라~)
- RAM에는 메모리 공간마다 주소가 달려있으므로 그 주소에 있는 것을 CPU 내의 레지스터로 가져오게 됨
- EAX라는 이름을 가진 레지스터가 있음 -> RAM에서 EAX로 가져오게 됨
- 즉, HDD의 1번 트랙 4번 섹터로 가서 그 안의 정보를 RAM으로 가져옴 -> 그 정보를 RAM 메모리의 15번에 저장해라~ -> 그 정보를 CPU 내의 EAX 레지스터에 가져와서 저장하라~

![](https://velog.velcdn.com/images/carmine/post/36cf7005-b55d-4c2a-bb0e-236b13cdf453/image.png)

- Format
  - HDD 사용하기 위해서는 포맷을 해야함 -> 아무 것도 없는 곳에 트랙과 섹터를 만들어서 집어 넣는 과정
  - 포맷을 하게 되면 트랙과 섹터가 생겨남

![](https://velog.velcdn.com/images/carmine/post/a9845635-aa2d-4d40-9d2f-cc6d041b08dc/image.png)

- 파일 할당 표(FAT)
  - 파일(정보 단위)이 어떤 트랙의 어떤 섹터에 저장되어 있는지 정리된 표
  - 디스크 조각 모음
  - 정보가 하나는 1번 트랙에, 하나는 2번, 하나는 3번 트랙에 있으면 정보 읽고 쓰는 데 속도 저하됨 -> 1번 트랙 1, 2, 3섹터처럼 연속되어 저장되어 있으면 속도 빨라짐 -> 정보의 조각들을 모아 연속된 공간에 저장하여 IO 속도를 개선하는 작업 = 디스크 조각모음

![](https://velog.velcdn.com/images/carmine/post/e6da0741-973d-4ebe-b1ed-d5b1221c2050/image.png)

- 중복이 없는 고유번호가 붙어있는 신발장이라는 공간에 신발을 넣음
  - 신발장 = RAM
  - 신발장을 이루는 한 칸 = 1바이트
  - 신발장의 번호 = 메모리 주소(=위치 정보)
  - 신발 = 정보
- 메모리 = RAM을 말하는 것
  - 1바이트라는 한 칸마다 일련 번호(주소 = 위치 정보)가 붙어 있음

![](https://velog.velcdn.com/images/carmine/post/3f9ace35-688c-466d-b6d4-ac1e70699cbe/image.png)

- 대략 42.9억개 = 2의 32승 = 32비트 = 4기가바이트

![](https://velog.velcdn.com/images/carmine/post/af85860c-1bf0-4474-84e9-e27adf5d5c63/image.png)

![](https://velog.velcdn.com/images/carmine/post/c8b753bc-81ef-4221-9bac-552158b8db9a/image.png)

- ALU: 컴퓨터의 핵심 연산 장치 (=전가산기)
  - 사칙 연산
  - 301번의 정보 3을 가져와서 두 번째 레지스터에 옮겨옴 -> 503번지의 4를 세 번째 레지스터에 옮겨옴
  - 옮겨오는 과정에서 캐시 메모리를 거치게 됨
  - 캐시
    - CPU는 초고속, RAM은 그냥 고속
    - CPU가 초고속으로 연산함 -> RAM은 상대적으로 느림 -> 캐시는 중간에서 CPU가 하려던 일에 필요한 정보들을 미리 가져옴
      - CPU가 연산할 때 필요한 것들을 미리 가져와 둠
      - CPU가 빨리 연산할 수 있게 RAM에서 미리 캐시로 정보 갖고 옴
- 64비트 CPU다 = 3, 4, 7이 모두 64비트로 표현됨

- 1. RAM에 가서 301번 안에 있는 정보를 가져옴
- 2. 캐시에 가져옴
- 3. CPU 내의 레지스터 A로 옮김
- 4. ALU가 연산
- 5. 연산 결과가 레지스터에 들어감
- 6. 레지스터에 들어간 정보를 메모리 어딘가로 옮겨감
  - 이런 한 줄 한 줄을 수행하는 것을 코드라고 함
  - CPU(=머신)가 인식하는 코드 = 머신 코드 = 기계어 코드
  - CPU 장치는 기계어 코드를 순차적으로 계속해서 계산하는 일을 함 -> 그 결과를 RAM이든 HDD든 저장


![](https://velog.velcdn.com/images/carmine/post/9d340819-4d8a-4d39-a993-d65a37ed28e4/image.png)

- 동시성
  - 라면 먹기라는 일과 TV보는 일은 동시성이 있나? -> 공간 분리 가능, 두 일 사이에 연관성 없어서 두 사람이 동시에 TV보고 라면을 먹을 수 있음
  - 행위 하는 주체가 한명이라면? -> 한 사람이 라면을 먹으면서 TV를 볼 수 있나? YES
  - 어떤 주체가 여러 행위를 동시에 하는 것 또한 동시성

![](https://velog.velcdn.com/images/carmine/post/a1a739d2-f74d-4781-9c13-e85a498b2bc5/image.png)

- 병렬성
  - 동시성의 부분집합
  - 같은 (한가지) 일을 여러 행위의 주체가 동시에 함
  - 인형에 눈을 붙이는 일을 여러 사람이 함께(동시에, 같은 공간에 들어와서) 처리할 수도 있음  효율 증대
  - 인형 눈알 붙이기라는 작업은 동시성을 넘어 병렬성이 있는 작업

![](https://velog.velcdn.com/images/carmine/post/65d77332-5af6-4a05-9617-6dc362e99dfd/image.png)

- 일을 동시에 하다 보면 충돌 가능성이 있음
  - 동시에 한 인형을 두 명이 잡게 되는 경우 등
- 원자성 보장되는 일
  - 화장실 들어가기 전 노크 -> 문 잠금 -> 볼일 보기 -> 문 열고 나옴
  - 볼일 보는 행위 자체에 대해 원자성 보장받기 위해 문을 잠금 -> 행위를 하는 데 방해받지 않기 위함
  - 볼일 보는 일련의 행위에 대해 원자성을 부여함
- 어떤 일 하는 데 있어서 개별화된 흐름(연산)이 존재 -> 그 흐름 속에서 어떤 공간에 대해 동시 접근할 수 있음 -> 충돌 발생
  - 화장실 들어갔는데 문 안 잠그면 한 화장실에 두 명이 들어가려고 하는 충돌이 발생할 수 있음
  - 제한된 환경에서 충돌 방지를 위해 동기화를 실시해야 함

![](https://velog.velcdn.com/images/carmine/post/bb6c6fce-9902-431d-be8a-5de85e49111e/image.png)

- 의존성

  - 사람들이 출근을 하는데, 그 개인들은 출근을 위해 버스에 의존적임 -> 버스 없으면 사람들은 출근할 수 없으므로 행위의 의존
  - 자동차 부품들은 자동차 자체가 사라지면 폐기되게 됨 -> 자동차 부품들은 자동차의 존재 자체에 의존

- 의존성
  - 사람들이 출근을 하는데, 그 개인들은 출근을 위해 버스에 의존적임 -> 버스 없으면 사람들은 출근할 수 없으므로 행위의 의존
  - 자동차 부품들은 자동차 자체가 사라지면 폐기되게 됨 -> 자동차 부품들은 자동차의 존재 자체에 의존

![](https://velog.velcdn.com/images/carmine/post/32521ce5-0ed7-46ad-9007-55fc2fea0345/image.png)

- 한 번에 여러 일 하면 충돌 발생할 수 있음
- 교차로에서 자동차들이 각자 움직이는데 규칙 정해서 신호 준수하지 않으면 충돌이 발생할 수 있음
- 화장실에서 볼일 볼 때 원자성 보장받고, 여러 명이 동시에 화장실 가려고 하면 한 사람이 들어가서 문을 잠그고 다른 사람들은 기다려야 함

![](https://velog.velcdn.com/images/carmine/post/1cda2b4e-f01a-4c07-a102-8edc472dacc9/image.png)

- 화장실 들어가서 문 잠금 -> 휴지가 없어서 화장실에서 나가지 못함 -> 바깥 사람들 중 한 명에게 휴지가 있음 -> 화장실에 들어간 사람이 밖으로 나오길 기다리고 있음
  - 기다리는 사람은 화장실에 들어갈 수 없고, 화장실에 들어간 사람은 밖으로 나올 수 없는 상태 = 교착상태
- 동시성에서 가장 중요한 것 = 동기화
  - 동기화: 화장실 들어갈 때 문 잠그는 것, 자동차가 교통 신호 준수하는 것
  - 문 잠그고 들어갔을 때 휴지가 없는 경우를 고려하지 못함 -> 동기화의 논리 구조에서 예외 처리를 잘 해야 교착상태 발생하지 않음

# 운영체제가 하는 일

- 운영체제(OS)
  - 접근 및 입출력 제어, 동기화, 전산 자원(CPU, RAM 등) 관리를 비롯한 많은 일 수행

![](https://velog.velcdn.com/images/carmine/post/a7d32601-3e9e-4d83-bc8e-51901eaf1f9a/image.png)

![](https://velog.velcdn.com/images/carmine/post/d3fb8b4f-3044-4998-b488-b42635473433/image.png)

- 프로세스 관리
  - 프로세스, 스레드
  - 각자의 업무 흐름은 프로세스의 전용 공간(=집) 내부로 제한됨
  - 화장실, 거실 등의 공간 구성 요소들은 집에 부여됨
    - 같은 가족이라도 구성원들은 각자 할 일을 함: 누구는 화장실 갈 수도, 누구는 티비 볼 수도 있음
    - 개인들은 그 공간들을 서로 공유함
  - CPU가 컴퓨터의 정체성을 결정함
  - 하드웨어 기반으로 운영체제라는 소프트웨어 존재하고 그 모든 것을 기반으로 어플리케이션 프로세스 존재 -> 프로세스 내에는 스레드 존재 -> 스레드의 흐름은 프로세스 내에서 개별적이며 프로세스에 할당된 자원을 항상 공유해서 씀(동시성) -> 동기화가 중요함

![](https://velog.velcdn.com/images/carmine/post/e974d363-8aeb-4979-9570-60e323e4161d/image.png)

- 스레드 = 개별화된 흐름
  - 프로그램의 흐름 = 스레드 단위로 존재함
- 프로세스 = 태스크

  - 태스크가 여러 개 있으면 멀티 태스킹
  - 동시에 태스킹 진행되므로 동기화 중요

    - A가 접근하고 있는 자원에 B가 접근하면 충돌 일어나므로 충돌 발생하지 않게 동기화 필요 -> OS가 관리

- OS가 하는 일

  - 스레드가 연산할 때 어떤 스레드가 어떤 CPU에서 연산될 지 결정
    - CPU를 스레드에 분배해서 연산 일어나게 함
  - 연산의 흐름이 작동할 때는 CPU 자원 써야 함 -> 누구는 대기하고 누구는 연산하고…를 OS가 스케줄링함
  - 프로세스가 사용하는 메모리를 할당 및 회수하는 일 또한 OS가 함

![](https://velog.velcdn.com/images/carmine/post/f0ca4be6-9c44-4d9c-b923-3b6d9f710001/image.png)

- 프로세스마다 메모리 공간 부여됨
- 스레드는 개별적 -> 스레드가 가족(프로세스)를 이룸
- 침실은 각 개인(스레드)가 개별적으로 씀 = 스택
  - 메모리 공간 관리될 때 스택 형식으로 관리되어서 스택으로 부름
  - 어떤 스레드 마다 스택이라는 공간을 둬서 각자의 스레드가 연산할 때 사용
- 거실, 주방, 화장실 등은 개인에게 부여되지 않음 -> 공유
  - 힙과 실행코드 영역
- 큰 공간(=집)을 가상 메모리 공간이라고 함
- 이 공간을 일정 크기로 잘라서 나눠서 사용
  - 스택 영역은 보통 1메가바이트
  - 거실과 같은 영역은 1.7기가바이트 정도

![](https://velog.velcdn.com/images/carmine/post/359674a6-f99d-404b-b22f-68018b05205a/image.png)

![](https://velog.velcdn.com/images/carmine/post/6b98df22-0cf3-4bc3-b93b-da0828def802/image.png)

- 가상 메모리
  - 운영체제는 페이지 단위로 메모리를 관리함
  - Paged / Non-Paged
- RAM과 하드디스크를 하나의 논리적 메모리로 추상화

![](https://velog.velcdn.com/images/carmine/post/8c9b1b31-12ba-4746-9574-c5df2fda9bef/image.png)

- 인터넷과 워드를 동시 실행 -> 페이지 단위로 운영체제가 메모리를 부여 -> 워드를 최소화 하고 인터넷 열었더니 메모리 공간이 꽉 참 -> 워드는 실제로 연산을 하고 있지 않으므로 운영체제가 워드가 쓰던 메모리를 하드디스크로 페이지 아웃(스왑 아웃) 시킴 -> 인터넷 쓰다가 닫고 워드를 재실행하면 바깥으로 빼둔 페이지를 RAM으로 페이지 인(스왑 인) 시킴
- 마치 여러 사람이 노트북 하나를 돌아가며 쓰듯 정해진 메모리 공간을 분할해서 공유하는 기법이 가상 메모리
  - 관리 단위: 페이지
  - 주기억장치 모자라면 하드디스크로 뺌
  - 각자는 주기억장치의 어딘가에 있다고 착각하지만 RAM에 있을 수도, HDD에 있을 수도 있음
  - 속도가 떨어져도 여러 프로세스가 동시에 작동될 수 있음



