---
title: "운영체제 기초 다지기"
datePublished: Sat Jul 01 2023 15:00:00 GMT+0000 (Coordinated Universal Time)
cuid: clr3bnrda000108l6gd6yh961
slug: os-basic-study
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1704621506737/e3424f39-3737-4052-80fa-6da52d395bcd.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1704621540735/1025ff2a-0fb0-498b-ab9c-52b0162afa48.png
tags: operating-system, basics, study

---

# 운영체제 개요

## 운영체제의 정의

![image](https://user-images.githubusercontent.com/67324487/224536794-d495473c-23a9-4031-8c14-7a016a29ef51.png)

- 정의: 컴퓨터 하드웨어 윗단, 각종 소프트웨어 밑단에 설치되어 사용자 및 모든 소프트웨어, 하드웨어를 연결하는 소프트웨어 계층
    - 광의의 운영체제: 메모리에 상주하지 않는 별도의 프로그램들
    - 협의의 운영체제: 커널(부팅이 일어난 이후 메모리에 항상 상주하는 부분)
        - 운영체제 또한 소프트웨어로서 컴퓨터의 전원이 켜짐과 동시에 메모리에 올라감 → 운영체제 전부가 메모리에 올라가면 공간 낭비 → 운영체제 중 항상 필요한 부분만 메모리에 상주시키고 그렇지 않은 부분은 필요할 때만 메모리에 올려서 사용
        - 커널: 메모리에 항상 상주하는 운영체제의 부분 = 운영체제의 핵심적인 부분

## 운영체제의 목적

![image](https://user-images.githubusercontent.com/67324487/224536800-cb65b228-7a78-4a69-b9c2-3401dbcacdb0.png)

![image](https://user-images.githubusercontent.com/67324487/224536801-13d1c8a9-bd60-43ee-ac52-f40dc113dfce.png)

- 컴퓨터 시스템의 자원을 효율적으로 관리하며, 편리하게 사용할 수 있는 환경을 제공하는 것
    - 자원(리소스)
        - 하드웨어 자원: 프로세서, 기억장치, 입출력 장치 등
        - 소프트웨어 자원: 프로세스, 파일, 메시지 등
- 효율성: CPU나 메모리와 같은 한정된 자원으로 최대한의 성능을 내도록
- 형평성: 특정 프로그램 또는 사용자가 차별받지 않도록
    - 각 프로그램들이 메모리를 적절히 차지할 수 있도록 조율
- 편의성: 여러 프로그램이 한 대의 컴퓨터에서 동시 실행되지만 사용자는 자신이 사용하고 있는 하나의 프로그램만 CPU를 점유하여 사용하고 있는 것처럼 느끼도록


# 컴퓨터 시스템 구조

## 컴퓨터 시스템 구조와 운영체제의 역할

![Untitled](https://user-images.githubusercontent.com/67324487/230755996-10f4d8f5-3e3a-4c57-b48c-ebf835cbb1fd.png)

![Untitled](https://user-images.githubusercontent.com/67324487/230756004-c16dd3b8-79ee-4ebd-a84b-baa08cb8e00d.png)

### 시스템 구성요소

- CPU: 중앙 처리 장치
  - 프로그램의 연산을 실행하고 처리하는 핵심 제어 장치
  - 프로그램 카운터라는 레지스터에서 메모리 주소를 읽어온 뒤, 그 메모리에 저장된 명령어(instruction)를 실행함
- 인터럽트 라인: 시스템에서 인터럽트를 처리하기 위한 하드웨어 라인
  - 컨트롤러가 인터럽트를 요청할 때 신호를 보내는 하드웨어 라인
    - CPU가 하나의 명령어를 실행 완료할 때마다 감지

![Untitled](https://user-images.githubusercontent.com/67324487/230756003-b50213e9-83b5-48c5-aa5b-44a0f3a3a0d0.png)

- 모드비트: CPU에서 실행되고 있는 것이 운영체제인지 사용자 프로그램인지 구분하는 역할 수행
  - 사용자 모드(1): 사용자 프로그램을 수행
    - CPU가 사용자 프로그램을 실행 중일 때
    - 제한된 instruction만 실행 가능하며 IO 장치 접근 불가
    - 운영체제가 CPU를 사용자 프로그램으로 넘겨줄 때 모드비트를 1로 변경해줌
  - 커널 모드(0): 운영체제 코드 수행
    - 운영체제가 CPU를 제어할 때
    - 메모리 접근 뿐만 아니라 IO 장치 접근 또한 가능
    - 인터럽트로 인해 CPU가 운영체제로 제어권을 넘기면 모드비트를 0으로 바꾸게 됨
- 레지스터: 메모리보다 더 빠르고 작은 기억 장치
- 메모리: CPU의 작업 공간
  - CPU는 매 클럭마다 메모리에서 기계어를 한 줄씩 읽어서 실행

![Untitled](https://user-images.githubusercontent.com/67324487/230756002-617a49ce-c58a-44c2-99af-f8d38aaa6ebe.png)

- 디바이스 컨트롤러: 각각의 IO 장치를 통제하는 컨트롤러
  - control register, status register: CPU가 디바이스 컨트롤러에게 작업을 시킬 때 명령 전달용으로써 기능
  - 로컬 버퍼: 각 디바이스 컨트롤러의 작업 공간(일종의 메모리)
    - 실제 데이터는 로컬 버퍼에 담김
  - 디바이스 드라이버: 각 디바이스에 접근할 수 있게 하는 소프트웨어
  - 디바이스 컨트롤러: 각 디바이스 별로 그것을 전담하는 하드웨어

![Untitled](https://user-images.githubusercontent.com/67324487/230756001-243f7e88-2e51-451e-a015-313d33806a85.png)

- DMA 컨트롤러: 메모리에 직접 접근할 수 있는 컨트롤러
  - 키보드로 글자를 하나 입력하는 등의 작은 작업들이 버퍼에 일정량 이상 쌓이면 직접 버퍼에 있는 내용들을 한번에 메모리에 복사해오는 장치
    - CPU가 너무 자주 인터럽트 당하지 않게 CPU 대신 IO 작업의 결과를 메모리로 복사해주는 역할 수행 → 작업이 다 끝나면 DMA가 CPU에 직접 인터럽트(Block 단위의 인터럽트)를 걸어서 내용이 메모리에 모두 적재되었음을 확인시킴
  - 즉, CPU를 대신하여 IO 장치의 작업 내용을 메인 메모리로 복사하고 IO 작업이 마무리되면 CPU에게 인터럽트를 걸어 알리는 역할
- 메모리 컨트롤러: 메모리에 접근 가능한 CPU와 DMA 컨트롤러 사이에서 교통정리 역할 수행

![Untitled](https://user-images.githubusercontent.com/67324487/230756000-13fcba3b-6dbd-4586-99b8-36925208890c.png)

- 타이머
  - 특정 프로그램이 CPU를 독점하는 것을 방지하기 위해 정해진 시간이 흐른 뒤에 운영체제로 제어권이 넘어가도록 인터럽트를 발생시키는 역할 수행
  - 매 클럭 틱마다 1씩 감소하며 타이머 값이 0이 되면 타이머 인터럽트 발생
    - CPU는 실제로 기계어를 한 줄 실행한 뒤 인터럽트 라인을 확인하는 것을 반복
  - 운영체제는 CPU를 사용자 프로그램에 넘겨줄 때 타이머에 시간을 세팅함 → CPU는 사용자 프로그램을 실행 → 세팅된 시간이 되면 타이머가 CPU에게 인터럽트 → CPU의 제어권이 운영체제로 넘어감
- 하드디스크: 보조 기억 장치이자 IO 장치

### 인터럽트란

![Untitled](https://user-images.githubusercontent.com/67324487/230755998-a7d4ad36-dd54-474b-ac50-c6e31d257d3e.png)

- CPU가 특정 작업을 처리하는 도중에 다른 작업을 수행하도록 하기 위해 사용되는 기능
  - 인터럽트 발생 시 CPU는 진행 중이던 작업을 중단하고 인터럽트를 통해 요구되는 작업을 우선적으로 처리
- 인터럽트의 종류
  - Interrupt (하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
    - IO 인터럽트: 입출력의 종료 또는 오류 등의 이유로 발생하는 인터럽트
  - Trap (소프트웨어 인터럽트)
    - Exception: 프로그램이 오류를 발생시킨 경우
      - 프로그램에서 명령어를 잘못 사용했거나 0으로 나누는 경우 등
    - System call: 프로그램이 커널 함수를 호출한 경우
      - 사용자 프로그램이 CPU를 점거하여 실행되고 있는 도중에 IO 작업이 필요한 경우
        - 사용자 프로그램은 운영체제를 통해서만 IO 장치에 접근 가능하므로 IO 작업이 필요하면 운영체제에게 시스템 콜을 통해 부탁함
        - IO 작업 필요 시 사용자 프로그램이 직접 인터럽트를 걺 → 모드비트가 0으로 바뀌고 CPU가 운영체제에게 넘어감 → IO 작업 수행 → IO 작업이 끝나면 하드웨어 인터럽트를 통해 종료를 알림
- 인터럽트 처리 루틴
  - 인터럽트의 종류가 여러 개이므로 각 인터럽트마다 수행하는 내용이 다 다름 → 인터럽트 별로 수행할 내용이 운영체제에 정의되어 있으며, 인터럽트 처리 루틴은 해당 처리 함수(코드)를 의미함
- 인터럽트 벡터
  - 인터럽트 별로 어느 주소의 함수를 실행해야 하는 지 해당 함수 주소를 정의해둔 것

### 운영체제의 역할

- CPU의 작동: 메모리에 적재된 사용자 프로그램은 CPU를 점거하여 실행되며, CPU는 매 클럭마다 프로그램의 기계어를 한 줄씩 실행 + 타이머 확인
- 인터럽트 발생
  - 프로그램이 직접 인터럽트를 발생시키는 경우
    - ex. 프로그램 실행 도중 키보드 입력을 받아야 하는 경우 → IO 작업이 필요하므로 인터럽트(시스템 콜) 발생
    - CPU가 운영체제로 넘어가며 운영체제가 해당 작업을 디바이스 컨트롤러에게 지시
      - CPU는 IO 장치에 직접 접근할 수 없으므로 디바이스 컨트롤러에게 입력을 받아오는 작업을 시킴
    - 디바이스 컨트롤러의 지시를 받아 IO 장치가 작업 수행하며, CPU는 다시 사용자 프로그램으로 돌아가 메모리 접근을 이어나감
    - 만약, 키보드의 입력이 꼭 필요한 작업이며 입력값이 없으면 프로그램 진행이 불가능한 경우 다른 프로그램으로 CPU 제어권이 넘어가게 됨
  - 디바이스 컨트롤러가 인터럽트를 발생시키는 경우
    - 사용자로부터 입력받은 데이터가 로컬 버퍼에 들어오면 디바이스 컨트롤러가 인터럽트 발생시킴 → CPU 제어권이 운영체제에게 돌아감
    - 운영체제는 입력받은 데이터를 로컬 버퍼에서 IO 작업을 요청한 사용자 프로그램의 메모리 공간으로 카피해둔 뒤, 실행 중이던 사용자 프로그램에게 다시 CPU 제어권을 양도
      - CPU는 메모리 뿐만 아니라 로컬 버퍼에도 접근 가능
    - 실행 중이던 사용자 프로그램의 할당 시간이 끝나면 CPU 제어권이 운영체제로 이동 → 운영체제가 IO 작업이 완료되어서 준비가 된 사용자 프로그램에게 CPU 제어권을 양도
    - DMA가 사용되는 경우
      - DMAC(DMAController)가 대신 입력받은 데이터를 메모리 공간에 카피한 뒤 인터럽트를 발생시켜 처리가 끝났음을 알림
  - 타이머가 인터럽트를 발생시키는 경우
    - 운영체제가 CPU를 점거하다가 사용자 프로그램에게 CPU 제어권을 넘겨줄 때 타이머에 시간을 세팅함
      - 무한 루프를 도는 프로그램을 만날 수도 있기 때문에

# 컴퓨터 시스템 구조

## 입출력의 실행

### 동기/비동기식 입출력

![Untitled](https://user-images.githubusercontent.com/67324487/235317366-03cf571c-8b42-4665-a7a6-206c28046d7c.png)

![Untitled](https://user-images.githubusercontent.com/67324487/235317381-cc3d1ebf-6a5b-49f2-9dd8-f1e52ad3d34b.png)

- 동기식 입출력
  - IO 작업 요청 → 작업 완료된 후에야 사용자 프로그램으로 CPU 제어권이 넘어가는 것
    - 즉, 완료된 작업물을 직접 확인한 뒤 읽어와서 중단했던 작업을 이어나가는 것
  - 구현 방법
    1. IO 작업이 완료될 때까지 대기하는 경우
       - CPU 뿐만 아니라 IO 장치 역시 한 가지 일만 하고 있으므로 낭비
    2. IO를 요청한 프로세스 말고 (IO 작업이 당장 필요하지 않은)다른 프로세스에게 CPU 제어권 양도
       - CPU와 IO장치 모두 낭비되지 않음
       - 단, IO 작업을 요청한 프로세스는 IO 작업이 완료될 때까지 다음 작업을 수행하지 못하고 기다려야 한다는 점은 여전함
- 비동기식 입출력
  - IO 작업 요청 → IO 작업이 진행되는 동안 무관한 다른 작업 실행하는 것
    - IO 작업의 결과를 확인하지 않아도 할 수 있는 작업을 실행하다가 IO 결과가 나오면 그와 연관된 작업을 이어나가는 것
- 동기/비동기식 입출력의 비교
  - 프로세스가 입출력을 요청하기 위해 인터럽트를 통해 CPU 제어권을 운영체제로 양도 → IO 작업은 시간이 많이 소요됨
    - 동기식: 프로세스가 IO 작업이 진행되는 동안 관계 없는 다른 명령어를 실행하지 않고 기다림
    - 비동기식: IO 작업 요청 후 기다림 없이 바로 다른 명령어 실행

### 서로 다른 입출력 명령어

![Untitled](https://user-images.githubusercontent.com/67324487/235317442-f0c88048-913e-41bc-99a3-dd21dd0d5569.png)

- IO를 수행하는 특별한 명령어에 의해 실행(좌측)
  - 일반적인 IO 작업
  - CPU가 실행하는 명령어는 메모리에 접근하는 경우와 IO 장치에 접근하는 경우로 나뉨
    - 즉, 메모리 접근 명령어 따로, IO 작업을 요청하는 명령어 따로 존재함
- Memory Mapped IO에 의해 실행(우측)
  - IO 장치들에 메모리 주소의 연장 주소를 부여한 뒤, 해당 주소로 메모리 접근 시 IO 작업을 수행하게 함
    - 즉, 만약 100번지에 대해 메모리 접근을 하면 일반적인 메모리 접근이고, 1000번지에 대해 접근하면 IO 작업을 수행함

### cf. 저장장치 계층 구조

![Untitled](https://user-images.githubusercontent.com/67324487/235317466-2c0babe9-c59d-45aa-937a-a191a250e86a.png)

![Untitled](https://user-images.githubusercontent.com/67324487/235317482-65cc2039-6d07-4633-b99f-96ca7ca8edae.png)

- 특징: 표의 상위에 위치할수록 속도가 빠르며, 단위 공간 당 가격이 비싸서 용량이 적음
  - Volatility: 휘발성의 유무 → 상위 세 개의 저장장치는 휘발성이며, 하위 세 개는 비휘발성
  - Primary/Secondary: CPU에서 직접 접근 가능한지 여부 → 바이트 단위로 접근이 가능하면 Primary, 그렇지 않으면 Secondary
- 캐싱: 메모리 간 속도 차이가 존재 → 속도 완충을 위해 캐시가 존재
  - 목적: 재사용
  - 이전에 요청했던 데이터와 같은 데이터를 요청하는 경우 메인 메모리까지 내려가지 않고 캐시에 저장된 데이터를 사용할 수 있음 → 속도 면에서 이점

## 프로그램의 실행

![Untitled](https://user-images.githubusercontent.com/67324487/235317496-ac528f5c-269f-48c6-8f39-7f368d16d946.png)

![Untitled](https://user-images.githubusercontent.com/67324487/235317508-a4a17ef3-0e4e-499f-86ef-68d9dc705446.png)

### Swap Area/Virtual Memory

- 프로그램
  - 실행 파일 형태로 하드 디스크에 저장되어 있음 → 메모리에 적재됨으로써 실행됨
- Swap Area과 Virtual Memory(가상 메모리)
  - 프로그램 실행 → 프로그램의 독자적인 주소 공간이 생성됨
    - 해당 주소 공간은 코드, 데이터, 스택 등으로 구성됨
  - 프로그램의 코드는 물리적인 메모리에 올라가야 실행이 되는데, 프로그램의 모든 코드를 통째로 올릴 시 메모리 낭비 문제 발생 → 당장 필요한 부분만 올려두고 그렇지 않은 부분은 디스크의 swap area라는 공간에 내려둠
    - Swap Area
      - 위 그림에 존재하는 두 개의 노란색 원통은 하드 디스크
        - 오른쪽: 파일 시스템 용도로 사용되며 컴퓨터의 전원이 꺼져도 파일의 내용을 유지함
        - 왼쪽(Swap Area): 메모리의 한계를 보완하기 위해 메모리 대용 공간으로 사용되며 전원이 꺼지면 필요 없어지는 정보들을 담음
  - 가상 메모리(Virtual Memory): 각 프로그램마다 독자적으로 가지는 메모리 주소 공간
    - 각 프로그램마다 주소 공간이 각각 존재하며, 물리적인 메모리에 올라갈 시 주소 변환 일어남(Address transition)

### 운영체제 커널의 주소 공간의 내용

![Untitled](https://user-images.githubusercontent.com/67324487/235317529-643f125c-6667-4b96-9934-74e8a2835591.png)

- 커널의 코드 영역
  - 시스템 콜 및 인터럽트를 처리하는 코드, 자원 관리를 위한 코드 등이 존재하는 영역
    - 운영체제는 인터럽트가 들어올 시 CPU 제어권을 획득할 수 있음 → 각 인터럽트 별로 어떤 작업을 처리해야 하는지 함수 형태로 구현되어 있음(=인터럽트 처리 코드)
- 커널의 데이터 영역
  - 운영체제가사용하는 여러 자료구조들이 정의되어 있는 영역
  - 하드웨어를 관리하기 위해 하드웨어 종류마다 자료 구조를 만들어서 관리
  - 프로세스들을 관리하므로 각 프로그램들을 관리하기 위한 자료 구조(PCB)가 존재하는 영역
- 커널의 스택 영역
  - 사용자 프로그램 별로 커널 스택을 따로 둠

### 사용자 프로그램이 사용하는 함수

![Untitled](https://user-images.githubusercontent.com/67324487/235317551-9c5518ea-ddc8-441d-91e2-8ab5622da271.png)

- 컴파일되어 실행 파일이 만들어지면 함수들은 사용자 정의 함수, 라이브러리 함수 등 종류와 관계 없이 다 해당 실행 파일 내에 포함됨
- 커널 함수
  - 운영체제 안에서 정의된 함수
  - 사용자 프로그램 내에 존재하는 것이 아닌, 커널 코드 내의 함수 → 해당 함수는 시스템 콜을 통해서만 호출 가능
    - 코드가 존재하는 영역 자체가 달라서 메모리 점프 불가능 → 시스템 콜을 통해 인터럽트 라인을 세팅하여 실행해야 함

### 프로그램 실행 과정

![Untitled](https://user-images.githubusercontent.com/67324487/235317566-dcf64984-c0f0-4bc0-a3d7-1e6f4c039548.png)

1. 사용자 프로그램 A 실행
2. A가 직접 CPU 제어권을 갖고 실행되는 유저 모드 내에서 실행됨 → 사용자 정의 함수 사용 가능
3. 커널 함수가 필요한 상황 발생 → 시스템 콜(인터럽트)
4. CPU 제어권이 운영체제로 양도되며 커널 모드로 전환 → 커널 모드에서 CPU가 동작하며 커널 주소 공간 내의 코드가 실행됨
5. 필요한 작업이 마무리되어 A에게 CPU 제어권이 넘어가고, A는 본인의 주소 공간 내의 코드를 실행
6. 프로그램 실행이 끝날 때까지 유저 모드 - 커널 모드를 반복

# 프로세스

## 프로세스의 개념

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/4cc65c83-61b1-46f6-b634-b0c4870a45b8)

- 프로세스: 실행 중인 프로그램
- 프로세스의 문맥: 특정 시점에서 이 프로세스가 어디까지 실행했는가
  - 프로세스의 현재 상태를 나타내기 위해 필요한 모든 것이 프로세스의 문맥을 구성함
    - 프로그램 카운터가 코드 영역의 어디를 가리키고 있는가
      - Program Counter(PC): 프로세스의 독자적인 주소 공간의 code부분을 가리키는 포인터
    - 각종 레지스터에 현재 어떤 값을 저장하고 있는가
  - 프로세스를 관리하는 역할인 운영체제가 해당 프로세스에 대해 어떤 값(PCB, 커널스택)을 갖고 있는지도 프로세스의 문맥에 해당함
    - PCB: 프로세스는 생성될 때마다 커널 주소 공간 내 data 영역에 PCB라는 자료구조를 생성함
    - 커널 스택: 시스템 콜이 발생하여 커널 내 code 영역의 함수가 실행될 때 그에 대한 정보가 들어있음

## 프로세스의 상태

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/370701f9-1f9d-43a8-9c46-99dfe1284803)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/5028a7f9-3b30-4d1a-a1a5-29ba30200c7f)

- 프로세스는 상태가 변경되며 수행됨
  - New: 프로세스가 생성 중인 상태
  - Running: CPU 제어권을 갖고 instruction을 수행하고 있는 상태
  - Ready: CPU가 디스크에는 접근 못하므로 당장 실행되어야 하는 instruction 부분들이 물리적인 영역(메모리)에 올라와있는 준비된 상태로 CPU 제어권을 할당받기까지 대기하는 상태
    - Running 상태에서 타이머 인터럽트에 의해 수행이 정지되면 Ready 상태로 전환됨
  - Blocked(wait, sleep): CPU 제어권을 할당받아도 당장 instruction을 수행할 수 없는 상태
    - 프로세스 자신이 요청한 event(IO, 디스크에서 파일 읽어오기 등)이 즉시 만족되지 않아 이것을 기다리는 상태
    - 자신이 요청한 event가 만족되면 Ready 상태가 됨
  - Suspended(stopped): CPU 뿐만 아니라 외부적인 이유로 프로세스의 수행이 정지된 상태이며 프로세스는 통째로 디스크로 swap out됨
    - 외부에서 다시 프로세스 수행을 재개해줘야 CPU 제어권을 점거할 수 있음
    - ex. 사용자가 프로그램을 일시 정지시킨 경우, 메모리에 너무 많은 프로세스가 올라와 있는 등의 이유로 프로세스를 잠시 중단시킨 경우 → 중기 스케줄러 내용 참조
  - Terminated: 프로세스의 수행이 끝난 상태

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/277b1df1-0e76-4328-a614-efbdf5c9a503)

- 프로세스가 시스템 콜을 해서 운영체제가 CPU 제어권을 얻어도 ‘운영체제가 Running 중인 상태’라고 표현하지 않음 → ‘해당 프로세스가 모니터 모드(커널 모드)로 Running 중인 상태’라고 표현함
- Suspended 상태여도 IO 작업 가능: IO가 완료되면 Suspended Blocked에서 Suspended Ready 상태로 변화
  - Suspended는 메모리에서 Swap out 당하는 것이므로 CPU의 관점에서는 아무 작업도 할 수 없는 것일 뿐, IO는 가능함

## Process Control Block

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/a1f75fe9-aa55-4d47-a374-30f383a6990d)

- PCB: 운영체제가 각 프로세스를 관리하기 위해 프로세스당 하나씩 생성하여 유지하는 정보
  - 다음의 구성 요소를 구조체로 유지
    - OS가 관리상 사용하는 정보
      - Process state: Ready, Running…etc.
      - Process ID
      - scheduling information, priority
        - 프로세스에게 CPU 제어권을 할당하기 위해서는 우선순위가 필요하며 이런 우선순위에 대한 값도 PCB에 저장됨
        - 먼저 대기 중인 프로세스에게 먼저 할당하지는 않음
    - CPU 수행 관련 하드웨어 값
      - Program counter, registers
    - 메모리 관련
      - Code, Data, Stack의 위치 정보
    - 파일 관련

## 문맥 교환 (Context Switch)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/694f6669-77a5-448f-9c07-10fa3685a665)

- 문맥 교환: CPU 제어권을 한 프로세스에서 다른 프로세스로 넘겨주는 과정
- CPU가 다른 프로세스에게 넘어갈 때의 운영체제가 수행하는 작업
  - CPU 제어권을 내어주는 프로세스의 상태를 해당 프로세스의 PCB에 저장 → CPU 제어권을 넘겨받는 프로세스의 상태를 PCB에서 읽어옴

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/711adc05-e8e6-4338-a5a3-f5004c4a9a47)

- 시스템 콜이나 인터럽트 발생 시 반드시 문맥 교환이 일어나지는 않음
  - 이후 운영체제가 CPU 제어권을 다른 프로세스에게 넘기면 문맥 교환이 일어남
- (1)의 경우: 인터럽트가 들어오거나 사용자 프로세스 A가 시스템 콜 할 때 커널 모드로 바뀌었다가 다시 유저 모드로 문맥 교환 없이 복귀하는 것
- (2)의 경우: 타이머 인터럽트 또는 IO 요청 시스템 콜의 경우 다른 사용자 프로세스에게 CPU 제어권을 넘김 → 커널 모드로 IO 요청 후, 다른 프로세스에게 CPU 제어권 넘기며 문맥 교환 발생

## 스케줄러

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/3c16dc0a-1938-4b7c-99f7-c9be302031bb)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/abd3c5cd-53ae-4361-a7ce-d39b051e0915)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/b4023e20-53c2-4632-ae61-0e40683ed8c2)

- 스케줄링: 각각의 자원 별로 어떤 작업을 수행할지, 얼마만큼의 시간을 소모할지 결정하는 것
- 장기 스케줄러: 메모리를 어떤 프로세스에게 줄지 결정
  - 시작된 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
  - 프로세스가 메모리에 적재되는 것이 허락되면 CPU 제어권을 얻을 수 있게 됨(New → Ready)
  - degree of Multiprogramming을 제어
    - Multiprogramming: 메모리에 여러 프로그램이 동시에 올라가 있는가
    - 즉, 장기 스케줄러가 메모리에 올라가 있는 프로세스의 수를 결정함
    - 메모리에 너무 많은/적은 프로그램이 올라가 있으면 성능이 저하/낭비됨
  - 보통 현재 통용되는 시스템에서는 장기 스케줄러가 필요하지 않음 → 중기 스케줄러가 유사한 역할을 대리
    - 만약 프로그램 100개를 실행시키면 일단 100개의 프로세스가 다 Ready 상태가 됨
- 단기 스케줄러(CPU 스케줄러)
  - 어떤 프로세스를 다음 범에 Running 시킬지 결정
  - 프로세스에 CPU 제어권을 주는 문제
  - 짧은 시간 단위로 스케줄링이 일어남
- 중기 스케줄러: 어떤 프로세스를 메모리에서 쫓아낼지
  - 메모리에 너무 많은 프로그램이 동시에 적재되어 있으면 여유 공간을 확보하기 위해 일부 프로그램을 골라 메모리에서 쫓아냄(Swap out)
  - 즉, Running 프로세스를 Suspended 상태로 변경함
  - degree of Multiprogramming을 제어
    - 현 시스템에서 장기 스케줄러가 하던 역할을 대리하는 것과 같음
# 스레드

## 스레드의 개념

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/2f874584-6dbc-4794-941d-8a973f3c1461)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/e6a246f7-a5d9-4b8a-9901-d806325cd37a)

- 스레드: 프로세스 하나에 CPU의 수행 단위만 여러 개 두는 것, 즉, 스레드 = CPU 실행 단위
  - 프로세스 하나만 Running하고, 현재 CPU가 해당 프로세스의 코드의 어느 부분을 실행하고 있는지에 대한 프로그램 카운터와 레지스터 내의 값에 대한 정보를 여러 개 두는 것
  - 각 스레드마다 주소 공간 내에서 스택, PCB 내에서 레지스터 셋, 프로그램 카운터를 별도로 갖고 있음
    - 프로세스의 instruction을 실행하려면 프로그램 카운터 있어야 함
    - CPU에서 instruction이 실행되면서 메모리 레지스터에 값들을 세팅함
    - 프로세스에서 함수를 호출하면 함수 호출 및 리턴 관련 정보를 주소공간 내 스택에 쌓음
    - 따라서 스레드끼리 공유할 수 있는 만큼 최대한 공유하되, CPU 수행과 관련된 것들만(PC, 레지스터 셋, 스택) 스레드마다 별로도 갖게 됨
- Lightweight process: 프로세스를 별도로 두는 것보다 프로세스 안에 스레드를 별도로 두는 게 낫기 때문에 Lightweight process라고 칭함
  - 동일한 작업을 수행하는 프로세스가 여러 개 있으면 프로세스마다 독자적인 주소 공간이 만들어지기 때문에 공간이 낭비됨

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/e0c36381-37ec-48cd-bddf-597378e13f1a)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/ab3a302e-2853-464f-909c-b5e9226a3ed4)

- 하나의 프로세스에 대해 한 개의 PCB가 생성되며, 프로세스 내 스레드가 여러 개면 코드, 데이터와 같은 여러 자원들은 스레드들끼리 공유하되 CPU 수행과 관련된 정보만(PC, 레지스터 셋) 스레드 별로 카피해서 갖게 됨

## 스레드의 장점

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/c1427a70-7f87-4d30-8c84-16722aca0865)

- 스레드 하나가 Blocked(waiting) 상태일 때 동일한 태스크 내의 다른 스레드가 Running되어 응답 시간이 빨라짐
  - 예를 들어, 네이버에 접속했을 때 네트워크를 통해 인터넷 페이지를 읽어오는(IO) 시간이 오래 걸리므로 웹 브라우저가 Blocked됨 → 해당 프로세스를 Blocked 시기는 게 아니라 하나의 스레드가 웹 페이지 내의 이미지를 불러오는 동안, 또 다른 스레드가 이미 읽어온 텍스트를 화면에 띄워주는 식으로 작업하면 사용자의 답답함이 덜함
  - 하나의 스레드가 A 작업을 하는 동안 다른 스레드들이 B, C…작업을 할 수 있어서 응답 시간 짧아질 수 있음
- 같은 일(ex. 인터넷 페이지 읽어오기)을 할 때 세부 작업(페이지 내 이미지 읽어오기, 텍스트 읽어오기 등)에 대한 프로세스를 따로따로 만들면 메모리를 많이 차지하게 됨 → 주소 공간(프로세스)를 하나만 띄워 놓고 스레드를 여러 개 둠 → 성능 향상

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/26343643-c87a-46a0-80c3-9c37dfa80ad3)

- 스레드 사용 시 장점 4가지
  - Responsiveness 응답성
    - 웹 브라우저로 네이버에 접속했을 경우
      - HTML 문서 수신 → 문서에 임베드된 이미지들을 웹 서버에 요청 → 이미지를 수신하면 화면에 텍스트와 이미지를 표시하게 되는데, 그 과정에서 시간이 소요되어 프로세스를 Blocked 시킴 → 사용자 입장에서는 지연으로 인해 불편함
    - 여러 개의 스레드를 갖고 있는 웹 브라우저로 접속했을 경우
      - HTML 문서 수신한 뒤 임베드된 이미지 파일들을 웹 서버에 요청 → 프로세스를 Blocked 시키지 않고, 웹 서버에 요청한 그 스레드만 Blocked 되고 다른 스레드가 수신된 문서라도 화면에 표시주면 사용자 입장에서 덜 불편함
      - 이미지를 수신하는 동안, 즉, IO 실행하는 동안 이 프로세스 자체를 Blocked 시키는 것이 아니라 이미지를 수신하는 결과와 무관하게화면에 HTML 문서를 먼저 표시해주는 것 (일종의 비동기식)
  - Resource Sharing 자원의 공유
    - 똑같은 작업을 하는 프로세스를 여러 개 두지 않고, 하나의 프로세스를 두고 그 안에 CPU 수행 단위(스레드)만 여러 개 둘 경우 코드, 데이터, 각종 자원을 스레드들 간에 공유하게 됨 → 자원을 효율적으로 사용하는 효과
  - Economy 경제성
    - 프로세스를 하나 만드는 것은 상당한 오버헤드 발생함 / 그러나 프로세스 내부에 스레드를 하나 추가하는 것은 오버헤드 크지 않음
    - Context Switching이 발생할 때 오버헤드 큼 / 프로세스 내부에서 스레드 간 switching 일어나는 것은 동일한 주소 공간을 사용하고 있으므로 대부분의 문맥을 그대로 사용할 수 있어서 오버헤드 작음
  - Utilization of MP Architectures
    - CPU가 여러 개일 경우 각각의 스레드가 서로 다른 CPU에서 병렬적으로 일하므로 더 효율적임

## 구현 방식에 의한 분류

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/680288b5-9f9e-4c81-8596-0d960739abdb)

- 스레드 구현 방식
  - 커널 스레드: 스레드가 여러 개 있다는 사실을 운영체제 커널이 인지하고 있음 → 하나의 스레드에서 다른 스레드로 CPU 제어권을 넘겨주는 역할을 커널이 담당함
  - 유저 스레드: 라이브러리를 통해 지원됨 → 프로세스 안에 스레드가 여러 개 있다는 사실을 운영체제는 인지하지 못하고 유저 프로그램이 스스로 라이브러리 지원을 받아서 여러 개의 스레드를 관리함 → 그러므로 유저 스레드는 커널이 모르고 있고, 커널이 볼 때는 일반적인 프로세스로 보이는데, 프로세스 본인 내부에서 CPU 수행 단위를 여러 개 두는 것이므로 구현 상에 제약이 있을 수 있음
    - 사용자 수준에서 스레드를 구현한 것
# 프로세스의 생성과 종료

## 프로세스 생성 (Process Creation)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/fd4dcc8d-5a4c-4165-aafa-c575aa3cd2b5)

- 프로세스를 생성하는 주체: 부모 프로세스
  - 부모 프로세스가 운영체제에 시스템 콜 해서 자식 프로세스 생성을 요청
  - 부모 프로세스가 자신과 똑같은 자식 프로세스를 복제해냄: 모든 맥락(주소 공간(메모리)의 코드, 데이터, 스택과 CPU 문맥을 나타내는 PC를 그대로 copy)
  - 자식 프로세스는 부모 프로세스를 그대로 카피하기 때문에 메모리 낭비 발생 → 리눅스와 같은 운영체제에서는 자식 프로세스가 부모 프로세스의 주소 공간을 공유하고 PC만 카피해서 동일한 위치를 가리키도록 함
    - 만약 부모 프로세스와 자식 프로세스가 달라지면 공유하던 부모 프로세스의 주소 공간 일부를 카피해서 자식 프로세스가 갖게 됨(=Copy-On-Write 기법)
      - Write가 발생하여 내용이 바뀔 때 카피, 그 전에는 부모 프로세스의 것을 그대로 공유
- 프로세스 트리(계층 구조)를 형성
  - 부모 프로세스 한 개가 여러 개의 자식 프로세스를 생성할 수 있으므로
- 프로세스를 실행하기 위해서는 CPU, 메모리와 같은 자원이 필요함
  - 자원을 운영체제로부터 받거나, 부모와 공유함
  - 일반적으로 부모 프로세스와 자식 프로세스는 경쟁 관계이므로 공유하지 않음

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/c1b7e67e-f850-4e93-a943-be5a1cbe241a)

- 프로세스는 부모 프로세스가 자식 프로세스를 복제 생성함
  - 부모 프로세스의 주소 공간을 자식 프로세스가 복사 → 운영체제에 있는 자원도(PCB 등) 복사 → 복제된 곳에 새로운 프로그램을 덮어 씌움
- Fork: 부모 프로세스를 복제함 / Exec: 새로운 프로그램을 덮어 씌움
  - 자식 프로세스를 만들지 않고 exec()을 통해 새로운 프로그램을 자기 자신에게 덮어 씌울 수도 있음
  - Fork와 Exec은 시스템 콜이기 때문에 결과적으로 운영체제에게 자식 프로세스를 생성해달라고 부탁하여 운영체제가 대신 생성해주는 것

## 프로세스 종료 (Process Termination)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/8c8751ba-6db9-448d-bfa8-bb757ab4204d)

- 자발적 종료: Exit 시스템 콜이 프로세스를 종료함 → 프로세스 종료 시 자식 프로세스가 부모 프로세스에 output 데이터를 전송함
  - 무조건 자식 프로세스가 부모 프로세스보다 먼저 종료되어야 함
- 강제 종료(Abort)
  - 자식 프로세스가 너무 많은 자원을 사용하는 경우
  - 자식 프로세스에 지시할 작업이 없는 경우
  - 부모 프로세스가 종료되는 경우
    - 부모 프로세스 종료 시 해당 프로세스의 자식 프로세스들이 계층 구조 최하단부터 단계적으로 종료됨

# 프로세스와 관련한 시스템 콜

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/abed0154-304f-4f60-b496-69e950f6a7b8)

## Fork() 시스템 콜

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/2d9333ea-20c7-474b-b831-360a75096396)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/879c8b08-eddd-43c9-a279-bb533607f002)

- fork() 함수 호출
  - 운영체제에 요청하는 시스템 콜
  - 자식 프로세스는 부모 프로세스의 문맥을 가져가므로 자식 프로세스는 fork() 함수 이후부터 코드를 실행함
    - 부모 프로세스의 PC가 `pid = fork()` 를 가리킨 후(= 해당 instruction이 CPU에 의해 실행된 후)에 자식 프로세스가 만들어지므로
  - 자식 프로세스를 복제 후, 자식 프로세스와 부모 프로세스의 구분 필요 → fork() 함수의 return값이 양수일 경우 부모 프로세스이며 0일 경우 자식 프로세스
    - fork()의 return값이 다르므로 부모 프로세스와 자식 프로세스를 구분할 수 있음

## Exec() 시스템 콜

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/8ab4c81f-7e56-4250-b4b9-949fe24cf296)

- exec() 함수 호출
  - 어떤 프로그램을 완전히 새로운 프로세스로 실행되게 함
  - fork()를 통해 자식 프로세스를 생성하고, 자식 프로세스는 execlp() 함수를 통해 exec() 시스템 콜 하게 됨 → 이전 맥락을 완전히 잃고, date를 출력하는 date 프로그램으로 새롭게 태어나게 됨
  - 한번 exec() 하게 되면 되돌아갈 수 없음

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/7b3b6913-9923-4ff6-afc3-0a2a2d47d4e5)

- 이와 같이 꼭 자식 프로세스를 만든 후 exec()을 할 수 있는 것은 아님
  - 대신 execlp() 이후의 printf는 실행 불가 → 프로세스가 완전히 새롭게 태어나기 때문

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/86db7113-6b6a-4e6c-b5c5-1420e9305f41)

- 위 프로세스는 1을 출력한 뒤, `echo`라는 새로운 프로그램으로서 3을 출력하고 종료됨
  - 2는 출력되지 않음

## Wait() 시스템 콜

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/76f65380-4c47-4c86-a8d3-e72c0ff0dd11)

- wait() 함수 호출
  - 자식 프로세스가 종료될 때까지 프로세스를 잠들게 함 == Blocked 상태로 만듦
    - 자식 프로세스 종료 시 Blocked 되어 있던 부모 프로세스를 깨워 Ready 상태로 만듦
  - 상기 이미지의 부모 프로세스는 자식 프로세스를 만든 뒤 wait() 시스템 콜을 하게 되므로 자식 프로세스가 종료되는 것을 기다리며 Blocked 상태가 되는 것
    - fork()한 이후, fork()의 return값이 0이 아니라면(= 부모 프로세스라면) wait() → 부모 프로세스가 CPU 제어권을 얻지 못하며(Blocked), 자식 프로세스가 자신의 코드를 다 실행한 후 종료되면 Blocked 상태에서 벗어남
  - 부모 프로세스와 자식 프로세스가 병렬적으로 실행되기도 하지만, 상기 경우처럼 부모 프로세스가 자식 프로세스를 기다리는 경우도 존재함

## Exit() 시스템 콜

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/f3498dd2-247d-4a03-bcec-2eeb260e28b0)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/dd6b1fe9-5bc1-47d1-8498-13c138e744ac)

- exit() 함수 호출
  - 프로세스의 자발적 종료
    - 마지막 statement 수행 후 exit() 시스템 콜을 통해 종료됨
    - 명시적으로 exit() 함수가 존재하지 않아도 컴파일러에 의해 main 함수가 return되는 위치에 삽입됨

# 프로세스 간 협력

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/75bee302-3965-4c59-a3db-cc55f210ce91)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/5fb7cb6e-8181-4182-ad67-39ff0d1f5220)

- 독립적 프로세스: 원칙적으로 프로세스는 독립적이며, 서로 데이터를 주고받으며 실행되지 않음
- 협력 프로세스: IPC를 통해 협력이 가능한 경우 존재함
- 프로세스 간 협력 매커니즘(Interprocess Communication)
  - 메세지를 전달하는 방식
    - message passing: 커널을 통해 프로세스 간 메세지를 주고 받음
  - 주소 공간을 공유하는 방식
    - shared memory: 두 프로세스가 일부 주소 공간을 공유하는 방법
      - 커널에 shared memory 매커니즘을 사용할 것이라는 시스템 콜을 해야 함
      - 두 프로세스가 서로 신뢰할 수 있는 관계여야 함
    - cf. 스레드들은 서로 주소 공간을 공유하기 때문에 완전한 협력이 가능함

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/9b3d5f4f-80da-4efa-916f-4df5a31ecf25)

- message passing - Mailbox 또한 커널에 존재함 - 통신 방식에 따른 분류: 두 방식 모두 커널을 통해 메세지를 주고받음 - 직접적인 통신: 통신하려는 프로세스의 이름을 명시적으로 표시 - 간접적인 통신: 커널에 존재하는 메일 박스, 또는 port를 통해 메세지를 간접적으로 전달



